This chapter serves as an introduction to the thesis by explaining the relevance of \emph{ECMAScript} \cite{ecma}, \emph{GraalVM} \cite{graalVMIntro} and \emph{Graal.js} \cite{Graaljs} in general and in the specific case of the ECMAScript proposal \emph{module blocks}. The chapter is wrapped up by an outline for the thesis.

ECMAScript \cite{ecma} is the standardized version of the web programming language \emph{JavaScript}. It is a general-purpose programming language extensively used in client-side scripting. The exact standards are \emph{ECMA-262} and \emph{ISO/IEC 16262}\cite{ecma}. The specification then in turn is implemented by so-called engines, conforming to the ECMAScript specification, that run JavaScript code. As of today, JavaScript is on spot three on the PYPL popularity index for programming languages \cite{pypl} indicating its popularity by Google search trends. As a core web technology it helped shaping online services as we see them today. An important part in the language becoming a core technology was browser support which had been a problem in the past. The particular support problem has been interoperability, i.e., where websites had to be programmed differently for different browsers due to their differences in JavaScript engine implementation\cite{10.1145/3386327}. These variations in turn then led to peculiar appearances or in the worst case non-working websites. That meant a huge programming overhead which wasn't sustainable in the long run. This issue was fixed by ECMAScript. Meanwhile a browser's engine's support is determined by feature support of the ECMAScript specification. The language specification development doesn't stagnate but is amended via a proposal process which is divided into five stages and is overlooked by an installed ECMA-committee, the so-called \emph{Technical Committee 39} (\emph{TC39}). Thus, new language features bundled into versions are developed in a standardized environment with the web community and vendors together as a team. 

In 2019 Oracle released the GraalVM \cite{graalVMStart} with active development up to present days. GraalVM  is a \emph{Java Virtual Machine (JVM)} with multiple core features such as bleeding-edge compiler optimizations, ahead-of-time compilation and polyglot programming. The multi-language runtime supports languages like JavaScript and LLVM via the \emph{Truffle} language implementation framework. With the amount of supported programming languages and the foregoing mentioned features the GraalVM can be embedded into a variety of production environments. One environment seems of particular interest: Microservices on server environments. The GraalVM native image was able to lower startup time and memory footprint by a significant amount \cite{graalVMNative}. These savings won over the social media platforms Twitter whose Microservices run on GraalVM \cite{graalTwitter} and Facebook using GraalVM for example at their big data, backend services and mobile areas \cite{facebook}. The engine in return created savings for their CPU times which makes it have an environmental impact. The other core feature of GraalVM is the support of multiple languages via the Truffle framework. With this framework different languages can be implemented on top of GraalVM \cite{graalVMIntro}. The framework itself provides a base for tree-based interpreter implementations. The different language implementations are split up into single projects for each language. This setup leads to the project Graal.js \cite{Graaljs}.

Graal.js \cite{Graaljs} is the Truffle implementation of ECMAScript on the GraalVM. The project implements the language specification with the Truffle framework. In essence, Graal.js transforms JavaScript source code into an \emph{abstract syntax tree (AST)} to be executed by any JVM. The main components to be introduced for the task include a parser, nodes for the resulting abstract syntax tree and a transformation logic for translating the parser produced intermediate representation to the aforementioned abstract syntax tree. The Graal.js interpreter can be executed on any Java-compliant JVM and provides full support for ECMAScript. Although it can be run on any JVM, execution with GraalVM has significant performance benefits, as it allows the automatic transformation of the AST into highly optimized machine code, a process called partial evaluation. All in all the system is an ECMAScript engine and thus, has to compete with other ECMAScript engines. With the official release of GraalVM 21 it showed to be on par with V8, Google's engine, and Spidermonkey, Mozilla's engine, with all three supporting 99\% of the newest ECMAScript version\cite{kangax1}. The big advantage Graal.js has over the other two engines is being embedded in the GraalVM ecosystem allowing polyglot programs. To keep up with current development the Graal.js project aims to implement proposals that haven't gone the whole way of the aforementioned proposal process and are yet to be released as new features of ECMAScript to be ahead of time. One of these yet to pass the process proposals is the module block proposal \cite{gitMB}.

\emph{Module blocks} are an effort by \emph{Daniel Ehrenberg} \footnote{https://github.com/littledan} and \emph{Surma} \footnote{https://github.com/surma} based on inline modules. Inlining modules is a feature which is missing from the current ECMAScript. The absence has resulted into workarounds with various issues. ECMAScript cannot share code between processes thus residing on a single thread. Every \emph{module}, \emph{worker} and \emph{worklet} needs a separate file cluttering project folders. A worker is basically opening a new context to run a module in a separate thread, i.e. the worker thread \cite{workers}. Tasks short of stringification cannot be shared across agents. The multitude of problems cited can be addressed by \emph{module blocks}. \emph{Module blocks} are a stage 2 proposal on ECMAScript~262 and is scheduled to be implemented in a future version of ECMAScript \cite{gitMB}. Since it has a high relevance for polyglot programs its implementation is key to staying on top of the technology stack which brings us to the purpose of this thesis.

The main objective of this thesis is to implement the current state of the ECMAScript \emph{module blocks} proposal in the Graal.js engine which is implemented via the Truffle framework. Finally, a code shipping framework with examples how to move code from one process to another using \emph{module blocks} is presented. The implementation will include tests and benchmarks to verify conformance, completeness and performance.

The thesis is divided into five further chapters. Chapter 2 explains the theoretical background of the thesis. In the following Chapter 3 the implementation and the testing is addressed. Afterwards, Chapter 4 evaluates the implementation with extensive tests, including a short benchmark test. The thesis is then finalized in Chapters 5 and 6 by highlighting future work and a conclusion.

% further notes to think about on thesis introduction
%Runtime relevancy - to stay relevant new features need to be implemented asap - module blocks\\

%module blocks -> inline modules -> general idea is to ship code between processes and thus potentially between machines over network -> bring logic to data not vice versa -> esp. important in database business environments

%Outline of thesis - 