This chapter serves as an introduction to the thesis by explaining the relevance for \emph{ECMAScript}, \emph{GraalVM} and \emph{Graal.js} in general and in the specific case of the ECMAScript proposal \emph{module blocks}. The chapter is wrapped up by an outline for the thesis.

ECMAScript \cite{ecma} is the standardized version of the famous internet front-end scripting language \emph{JavaScript}. The ECMAScript specification includes language features and their expected behavior each scripting language should have. The specification then in turn is implemented by so-called engines that run JavaScript code. JavaScript is on spot three on the PYPL popularity index for programming languages indicating its popularity by google search trends. \cite{pypl} As a core technology of the internet it helped shaping the web as we see it today. An important part in the language becoming a core technology was browser support which had been a problem in the past. The particular support problem has been interoperability, i.e. where websites had to be programmed differently for different browsers due to their differences in JavaScript engine implementation. \cite{10.1145/3386327} These variations in turn then led to peculiar appearances or in the worst case non-working websites. That meant a huge programming overhead which wasn't feasible in the long run. This issue was fixed by ECMAScript. Meanwhile a browser's engine's support is determined by feature support of the ECMAScript specification. The language specification development doesn't stagnate but is amended via a proposal process which is divided into five stages and is overlooked by an installed ECMA-committee, the so-called \emph{TC39}. Thus, new language features bundled into versions are developed in a standardized environment with the web community and vendors together as a team. 

In 2019 Oracle released the GraalVM with active development up to present days. GraalVM \cite{graalVMStart} is a \emph{Java Virtual Machine (JVM)} with multiple core features such as certain compiler optimizations, ahead-of-time compilation, polyglot programming, making it a multilingual runtime, \emph{Low Level Virtual Machine (LLVM)} runtime and the \emph{Truffle} language implementation framework. With the amount of supported programming languages and the foregoing mentioned features the GraalVM can be implemented into a variety of production environments. One environment seems of particular interest: Microservices on server environments. The GraalVM native image was able to lower startup time and memory footprint by a significant amount. \cite{graalVMNative} These savings won over the social media platform Twitter whose Microservices run on GraalVM. \cite{graalTwitter} The engine in return created savings for their CPU times which makes it have an environmental impact. The other core feature of GraalVM is the support of multiple languages via the Truffle framework. With this framework different languages can be implemented on top of GraalVM. \cite{graalVMIntro} The framework itself provides a base for tree-based interpreter implementations. The different language implementations are split up into single projects for each language. This setup leads to the project Graal.js.

Graal.js is the Truffle implementation of ECMAScript on the GraalVM. The project implements the language specification with the Truffle framework. In essence, the project transforms JavaScript source code into an \emph{abstract syntax tree (AST)} to be executed by any JVM. \cite{Graaljs} The main components to be introduced for the task include a parser, nodes for the resulting abstract syntax tree and a transformation logic for translating the parser produced intermediate representation to the aforementioned abstract syntax tree. The Graal.js interpreter can be executed on any Java-compliant JVM and provides full support for ECMAScript. Although it can be run on any JVM, execution with GraalVM has significant performance benefits, as it allows the automatic transformation of the AST into highly optimized machine code. All in all the system is an ECMAScript engine and thus, has to compete with other ECMAScript engines. With the official release of GraalVM 21 it showed to be on par with V8, Google's engine, and Spidermonkey, Mozilla's engine, with all three supporting 99\% of the newest ECMAScript version. \cite{kangax1} The big advantage Graal.js has over the other two engines is being embedded in the GraalVM ecosystem allowing polyglot programs. To keep up with current development the Graal.js project aims to implement proposal that haven't gone the whole way of the aforementioned proposal process and are yet to be released as new features of ECMAScript to be ahead of time. One of these yet to pass the process proposals is the module block proposal.

Module blocks are an effort by \emph{Daniel Ehrenberg} \footnote{https://github.com/littledan} and \emph{Surma} \footnote{https://github.com/surma} based on inline modules. Inlining modules is a feature which is missing from the current ECMAScript. The absence has resulted into workarounds with various issues. ECMAScript cannot share code between processes thus residing on a single thread. Every \emph{module}, \emph{worker} and \emph{worklet} needs a separate file cluttering project folders. A worker is basically opening a new context to run a module in a separate thread, i.e. the worker thread. \cite{workers} Tasks short of stringification cannot be shared across agents. The multitude of problems cited can be addressed by module blocks. Module blocks are a stage 2 proposal on ECMAScript~262 and is scheduled to be implemented in a future version of ECMAScript. \cite{gitMB} Since it has a high relevance for polyglot programs its implementation is key to staying on top of the technology stack which brings us to the purpose of this thesis.

The main objective of this thesis is to implement the new ECMAScript stage 2 proposal module blocks into the Graal.js engine which is implemented via the Truffle framework. Furthermore testing for this implementation will be conducted. When the general workings are set a code shipping framework and benchmarks will be included.

The thesis is divided into five further chapters. Chapter 2 explains the theoretical background of the thesis. In the following Chapter 3 the implementation and the testing is addressed. Afterwards, Chapter 4, evaluates the implementation with extensive tests. The thesis is then rounded up in Chapter 5 and 6 by highlighting future work and a conclusion.

% further notes to think about on thesis introduction
%Runtime relevancy - to stay relevant new features need to be implemented asap - module blocks\\

%module blocks -> inline modules -> general idea is to ship code between processes and thus potentially between machines over network -> bring logic to data not vice versa -> esp. important in database business environments

%Outline of thesis - 