The presented module blocks implementation which has been embedded inside the Graal.js project, was evaluated by running the provided tests in the project. Those tests represent the Test262 implementation conformance test suite. \cite{ecmaTest262} Since these tests can't cover module block syntax and semantics additional tests were conducted.

The Test262 suite combines the three ecma standards ECMA-262, ECMAScript Language Specification, ECMA-402, ECMAScript Internationalization API Specification and ECMA-404 the JSON Data Interchange Syntax, also known as ISO/IEC 21778. The suite's test files cover any  behavior stated in these specifications and is comprised of around 30.000 individual test files. \cite{ecmaTest262, ecmaTestSpec} Although the test environment is extensive full coverage cannot be guaranteed. It's certain to say that the suite doesn't yet contain any tests that cover module block functionality. This shifts the topic towards the tests that were designed and conducted in the course of this thesis.

The main orientation for designing tests regarding the module block proposal came from the available basic specification. While it is not finished yet, the parts of the specification that could be implemented can also be tested. First of, the syntactic part of the specification can already pose different testing scenarios.

    \begin{lstlisting}[caption={Module block syntax tests}, label={fig:testSyntax}]
        var module = 42;
        
        var nextModule = module;
        
        var moduleBlock = module { };
        
        var failingModuleBlock = module
            { };
    \end{lstlisting}

The first syntactic specialty is the fact that "module", while acting as a keyword in the scope of module blocks, won't be added to the keywords group in ECMAScript. The consequences are random variables being used with "module" as identifier are allowed and line delimiters between \texttt{module} and the \texttt{\{} are forbidden. Since the \texttt{ModuleBody} part of the module block syntax  is optional an empty module like in line three of Listing \ref{fig:testSyntax}. This concludes the three testing cases for the syntax. Next up are tests regarding the prototype and the constructor.

The constructor of module blocks basically doesn't have to exist as it simply should throw a \texttt{TypeError}. The decision during implementation was made that it actually is implemented but when called throws the specified error. Still it doesn't change the expected behavior and thus a simple call to the constructor is made and expects the aforementioned error. Testing the prototype requires more elaborate testing since multiple aspects need to be checked. Those regard especially the prototype property of the module block prototype object itself but also the module block prototype property. The described tests are conducted by source code similar to Listing \ref{fig:testCoPro}.

    \begin{lstlisting}[caption={Module block constructor and prototype tests}, label={fig:testCoPro}]
        var constructorModuleBlock = new ModuleBlock(); // TypeError: ModuleBlock is not a constructor
        
        var moduleBlock = module { };
        
        var instanceTest = moduleBlock instanceof ModuleBlock; // true
        
        var moduleBlockPrototype = moduleBlock.constructor.prototype; // object
    \end{lstlisting}

The following tests mainly regard the module blocks interaction with different ECMAScript constructs inside of the module block, in particular the optional syntax part \texttt{ModuleBody}, and its interaction with the dynamic import. The interaction with existing ECMAScript structures is straightforward as all of them have to be used inside a module block as part of the \texttt{ModuleBody} to some extent. The following Listing \ref{fig:testGeneral} list some example cases with a simple number variable, a function and an async function.

    \begin{lstlisting}[caption={Module block general test example cases}, label={fig:testGeneral}]
        var moduleBlock = module { export var x = 42; }; // export number
        
        var moduleBlockFunc = module { export function square(x) {
                return x * x;
            } 
        }; // export function
    
        var moduleBlockAsync = module {
            function resolve() {
                return new Promise(resolve => {
                        resolve('resolved inside module block')
                });
            }
        
            async function asyncCall() {
                return await resolve();
            }
        
            export var resolved = asyncCall(); 
        }; // export promise
    \end{lstlisting}

A particular case that should also be noted as it raised interest during the proposal presentation is the ability to bundle module imports into a module block which was also tested extensively with importing modules in the different possible ways and also importing module blocks. The specialties of module block imports are explained in the next bit.

Module blocks can only be imported dynamically with awaits. Since top level awaits are not supported dynamic imports have to be encapsulated in async functions. Hence imported module block module records are encapsulated in a promise and have to be processed in a then-environment. Listing \ref{fig:testImp} shows the exact syntax needed for importing the module block.

    \begin{lstlisting}[caption={Module block dynamic import test}, label={fig:testImp}]
        var test = (async function() {
            var moduleBlock = module { export var x = 42; }; // export number
            
            return await import(moduleBlock);
        })();
        
        test.then( function(module) {
            console.log("Module block x: " + module.x);  // Module block x: 42
        });
    \end{lstlisting}

In conclusion adding a new feature into an engine for ECMAScript requires extensive testing. First of the general preexisting test suite Test262 has to be applied to the changed semantics and have to pass. Then all intricacies of the proposal's specification have to be tested. Although the proposal is a rather syntactic one it still introduces semantics which have to be tested. Next up after all internals are checked the interaction with preexisting ECMAScript structures needs to take place which furthers the extensiveness of testing.